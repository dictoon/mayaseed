
//
// Copyright (c) 2012 Jonathan Topf
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

// Platform-specific configuration.
#define REQUIRE_IOSTREAM
#if defined __APPLE__
    #include <maya/OpenMayaMac.h>
#endif

// Maya headers.
#include <maya/MArgList.h>
#include <maya/MDagPath.h>
#include <maya/MFloatArray.h>
#include <maya/MFloatVector.h>
#include <maya/MFloatVectorArray.h>
#include <maya/MFnDependencyNode.h>
#include <maya/MFnMesh.h>
#include <maya/MGlobal.h>
#include <maya/MIntArray.h>
#include <maya/MItMeshPolygon.h>
#include <maya/MObject.h>
#include <maya/MObjectArray.h>
#include <maya/MPlug.h>
#include <maya/MPlugArray.h>
#include <maya/MPoint.h>
#include <maya/MPointArray.h>
#include <maya/MSelectionList.h>
#include <maya/MSimple.h>
#include <maya/MStatus.h>
#include <maya/MString.h>

// Standard headers.
#include <fstream>
#include <vector>

#if defined _WIN32
    #if defined ms_export_obj_EXPORTS
        #define DLLSYMBOL __declspec(dllexport)
    #else
        #define DLLSYMBOL __declspec(dllimport)
    #endif
#else
    #define DLLSYMBOL
#endif

using namespace std;

const MString Version("0.1.3");

DLLSYMBOL MStatus initializePlugin(MObject _obj);
DLLSYMBOL MStatus uninitializePlugin(MObject _obj);

DeclareSimpleCommand(ms_export_obj, "mayaseed", Version.asChar());


//
// Reference:
//
//   robthebloke.org, Intermediate Exporter + Viewer:
//   http://nccastaff.bournemouth.ac.uk/jmacey/RobTheBloke/www/index.html
//

MStatus ms_export_obj::doIt(const MArgList& args)
{
    // Extract arguments.
    MString mesh_name;
    MString file_path;
    for (unsigned int i = 0; i < args.length(); i++)
    {
        if (args.asString(i) == "-mesh")
            mesh_name = args.asString(++i);
        else if (args.asString(i) == "-filePath")
            file_path = args.asString(++i);
    }

    MString display_info;
    display_info.format("Exporting ^1s to ^2s using ms_export_obj (native)", mesh_name, file_path);
    MGlobal::displayInfo(display_info);

    // Open file for writing, overwriting previous contents.
    ofstream out_file;
    out_file.open(file_path.asChar(), ios::trunc);
    out_file << "# File generated by ms_export_obj (native) version " << Version.asChar() << endl;

    MSelectionList sel;
    sel.add(mesh_name);

    MDagPath mesh_dag_path;
    sel.getDagPath(0, mesh_dag_path);

    MFnMesh mesh(mesh_dag_path);

    // Write vertices.
    MPointArray point_array;
    mesh.getPoints(point_array);
    const unsigned int point_count = point_array.length();
    for (unsigned int i = 0; i < point_count; ++i)
    {
        const MPoint& p = point_array[i];
        out_file << "v " << p.x << ' ' << p.y << ' ' << p.z << endl;
    }

    // Write UV coordinates.
    MFloatArray u_array, v_array;
    mesh.getUVs(u_array, v_array);
    const unsigned int uv_count = u_array.length();
    for (unsigned int i = 0; i < uv_count; ++i)
    {
        out_file << "vt " << u_array[i] << ' ' << v_array[i] << endl;
    }

    // Write normals.
    MFloatVectorArray normal_array;
    mesh.getNormals(normal_array, MSpace::kTransform);
    const unsigned int normal_count = normal_array.length();
    for (unsigned int i = 0; i < normal_count; ++i)
    {
        const MFloatVector& n = normal_array[i];
        out_file << "vn " << n.x << ' ' << n.y <<  ' ' << n.z << endl;
    }

    // Build a list of all surface shaders used on the mesh. Note that
    // the nodes returned are the shading groups, not the material nodes!
    MObjectArray shaders;
    MIntArray shader_indices;
    mesh.getConnectedShaders(0, shaders, shader_indices);

    // Build array of material names.
    vector<MString> material_names;
    for (unsigned int i = 0; i < shaders.length(); ++i)
    {
        const MFnDependencyNode shader(shaders[i]);
        const MPlug surface_shader = shader.findPlug("surfaceShader");

        MPlugArray materials;
        surface_shader.connectedTo(materials, true, true);

        for (unsigned int j = 0; j < materials.length(); ++j)
        {
            const MFnDependencyNode material(materials[j].node());
            material_names.push_back(material.name());
        }
    }

    // Write faces.
    unsigned int face_index = 0;
    unsigned int last_shader_index = ~0;
    MItMeshPolygon poly_it(mesh.object());
    while (!poly_it.isDone())
    {
        const int shader_index = shader_indices[face_index];
        if (shader_index != last_shader_index)
        {
            last_shader_index = shader_index;

            out_file << "usemtl ";
            out_file << (shader_index == -1 ? "no_material" : material_names[shader_index]);
            out_file << endl;
        }

        out_file << 'f';

        const unsigned int vertex_count = poly_it.polygonVertexCount();
        for (unsigned int i = 0; i < vertex_count; ++i)
        {
            out_file << ' ' << (poly_it.vertexIndex(i) + 1);

            if (uv_count > 0 || normal_count > 0)
                out_file << '/';

            if (uv_count > 0)
            {
                int uv_index;
                poly_it.getUVIndex(i, uv_index);
                out_file << (uv_index + 1);
            }

            if (normal_count > 0)
                out_file << '/' << (poly_it.normalIndex(i) + 1);
        }

        out_file << endl;

        ++face_index;
        poly_it.next();
    }

    // Close the file.
    out_file.close();

    return MS::kSuccess;
}
